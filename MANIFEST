fork1.c -> simple usage of fork and decoding of status
fork2.c -> lifting out the usage code into a separate function
fork3.c -> handling several simple children
fork3bad.c -> checking that error checking works by injecting faults
fork3bad2.c -> removing atomicity of printf
fork4.c -> some fairly horrible code that works because of how stdio works
fork5.c -> a simple variation of error handling with passthru
fork6.c -> some more simple puzzle pieces with fork

pipe1.c -> use a pipe to talk back to the parent
pipe2.c -> actually send structured data back
pipe3.c -> demonstrate showing the results as we get them
pipe4.c -> now we can go back to explicitly waiting on our children
pipe4bad.c -> inject fault (hung child) to see how we fare

server1.c -> trivial (bad) server example
server2.c -> delegating stuff to external program: exec + dup2
server3.c -> setsockopt + debug mode
server4.c -> modern internet
